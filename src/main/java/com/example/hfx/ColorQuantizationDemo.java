package com.example.hfx;


import javafx.embed.swing.SwingFXUtils;
import javafx.scene.control.ScrollPane;
import javafx.scene.layout.StackPane;

import javafx.scene.text.Text;
import javafx.stage.Stage;
import javafx.geometry.Pos;
import javafx.geometry.Insets;
import javafx.scene.layout.VBox;
import javafx.scene.Scene;
import javafx.scene.layout.GridPane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Rectangle;

import java.awt.image.*;
import java.util.List;

import javafx.application.Application;
import javafx.scene.chart.BarChart;
import javafx.scene.chart.CategoryAxis;
import javafx.scene.chart.NumberAxis;
import javafx.scene.chart.XYChart;
import javafx.scene.control.Button;
import javafx.scene.control.ComboBox;
import javafx.scene.effect.DropShadow;
import javafx.scene.image.*;
//import javafx.scene.image.Image;
import javafx.scene.layout.*;
import javafx.stage.FileChooser;

import javax.imageio.ImageIO;
import javax.swing.*;
import java.io.File;
import java.io.IOException;
import java.util.*;

import java.util.concurrent.atomic.AtomicInteger;


public class    ColorQuantizationDemo extends Application {

    private Image originalImage;
    private Image quantizedImage;

    @Override
    public void start(Stage primaryStage) {

        ComboBox<Integer> colorDeep = new ComboBox<Integer>();
        colorDeep.getItems().addAll(2, 4, 8, 16, 32, 64, 128, 256, 10000);
        colorDeep.setValue(16);

        AtomicInteger value = new AtomicInteger(colorDeep.getValue());
        colorDeep.valueProperty().addListener((observable, oldValue, newValue) -> {
            value.set(newValue);
        });

        ComboBox<String> option = new ComboBox<String>();
        option.getItems().addAll("K_Means", "MedianCut");
        option.setValue("K_Means");
        Button searchButton = new Button(" image Search ");
        searchButton.setOnAction(event -> {

            ImageSearchApp s = new ImageSearchApp();
            Stage a = new Stage();
            s.start(a);
            event.consume();
        });

        Button chooseImageButton = new Button("Choose Image");
        chooseImageButton.setOnAction(event -> {
                    Stage stage = new Stage();
                    String selectedOption = option.getValue();
                    try {
                        handleChooseImage(stage, value.get(), selectedOption);
                    } catch (IOException e) {
                        throw new RuntimeException(e);
                    }
                    event.consume();
                }
        );

        VBox vbox = new VBox(10, colorDeep, option, chooseImageButton, searchButton);
        vbox.setAlignment(Pos.CENTER);
        StackPane root = new StackPane(vbox);
        Scene scene = new Scene(root, 400, 400);
        primaryStage.setScene(scene);
        primaryStage.show();

    }
    private void handleChooseImage(Stage stage, int value, String selectedOption) throws IOException {
        double elapsedTime;
        FileChooser fileChooser = new FileChooser();
        fileChooser.setTitle("Select Image");
        fileChooser.getExtensionFilters().addAll(
                new FileChooser.ExtensionFilter("Image Files", "*.png", "*.jpg", "*.jpeg", "*.gif"));
        File selectedFile = fileChooser.showOpenDialog(stage);
        if (selectedFile != null) {
            long startTime = System.currentTimeMillis();
            originalImage = new Image(selectedFile.toURI().toString());
            ImageView imageView = new ImageView(originalImage);
            imageView.setFitWidth(300);
            imageView.setFitHeight(300);

            if (selectedOption.equals("K_Means")) {
                KMeans km =new KMeans();
                quantizedImage = km.applyKMeans(originalImage,value);
            } else {
                quantizedImage = MedianCut.applyMedianCut(originalImage, value);
            }

            long endTime = System.currentTimeMillis();
            elapsedTime = (double) (endTime - startTime) / 1000; // Convert to milliseconds

            ImageView quantizedImageView = new ImageView(quantizedImage);
            quantizedImageView.setFitWidth(300);
            quantizedImageView.setFitHeight(300);


            Button saveButton = new Button("Save Indexed Images");
            saveButton.setOnAction(event -> {
                saveImage(quantizedImageView.getImage());

                event.consume();
            });
            // Replace this fixed color palette with the one generated by your color quantization algorithm

            List<Color> colorPalette = getPaletteColors(quantizedImage);
            Button colorPaletteBtn = new Button("Show Color Palette");
            colorPaletteBtn.setOnAction(event -> {
                createColorPaletteBox(colorPalette);
                event.consume();
            });

            Button histogramBtn = new Button("color histogram");
            histogramBtn.setOnAction(event -> {
                createHistogram(quantizedImageView.getImage());

                event.consume();
            });


            HBox hbox = new HBox(20, imageView, quantizedImageView);
            hbox.setAlignment(Pos.CENTER);

            HBox buttonBox = new HBox(20, colorPaletteBtn, saveButton, histogramBtn);
            buttonBox.setAlignment(Pos.BOTTOM_CENTER);
            buttonBox.setPadding(new Insets(10, 10, 20, 10));

            Text timeText = new Text("Execution Time: " + elapsedTime + " s");
            timeText.setFill(Color.BLUE);

            VBox container = new VBox(10, timeText, hbox, buttonBox);
            container.setAlignment(Pos.CENTER);

            Scene scene = new Scene(container, 800, 400);
            Stage stage1 = new Stage();

            stage1.setScene(scene);
            stage1.show();
        }
    }

    public List<Color> getPaletteColors(Image quantizedImage) {
        PixelReader pixelReader = quantizedImage.getPixelReader();
        Set<Color> colors = new HashSet<>();
        for (int x = 0; x < quantizedImage.getWidth(); x++) {
            for (int y = 0; y < quantizedImage.getHeight(); y++) {
                Color color = pixelReader.getColor(x, y);
                colors.add(color);
            }
        }
        return new ArrayList<>(colors);
    }

    private static IndexColorModel createIndexColorModel(int numColors) {

        int[] colors = new int[numColors];
        for (int i = 0; i < numColors; i++) {
            float hue = (float) i / numColors;
            java.awt.Color color = java.awt.Color.getHSBColor(hue, 1.0f, 1.0f);
            colors[i] = color.getRGB();
        }


        return new IndexColorModel(8, numColors, colors, 0, false, -1, DataBuffer.TYPE_BYTE);
    }


    public BufferedImage convertToIndexed(BufferedImage image, int numColors) {
        int width = image.getWidth();
        int height = image.getHeight();
        IndexColorModel indexedColorModel = createIndexColorModel(numColors);
        BufferedImage indexedImage = new BufferedImage(width, height, BufferedImage.TYPE_BYTE_INDEXED, indexedColorModel);
        int[] pixel = new int[3];
        byte[] index = new byte[1];
        byte[] mapReds = new byte[numColors];
        byte[] mapGreens = new byte[numColors];
        byte[] mapBlues = new byte[numColors];
        indexedColorModel.getReds(mapReds);
        indexedColorModel.getGreens(mapGreens);
        indexedColorModel.getBlues(mapBlues);

        for (int y = 0; y < height; y++) {
            for (int x = 0; x < width; x++) {
                int rgb = image.getRGB(x, y);
                java.awt.Color color = new java.awt.Color(rgb);
                pixel[0] = color.getRed();
                pixel[1] = color.getGreen();
                pixel[2] = color.getBlue();
                int minDistance = Integer.MAX_VALUE;
                int bestIndex = 0;

                for (int i = 0; i < numColors; i++) {
                    int distance = (pixel[0] - (mapReds[i] & 0xff)) * (pixel[0] - (mapReds[i] & 0xff)) +
                            (pixel[1] - (mapGreens[i] & 0xff)) * (pixel[1] - (mapGreens[i] & 0xff)) +
                            (pixel[2] - (mapBlues[i] & 0xff)) * (pixel[2] - (mapBlues[i] & 0xff));

                    if (distance < minDistance) {
                        minDistance = distance;
                        bestIndex = i;
                    }
                }

                index[0] = (byte) bestIndex;
                indexedImage.getRaster().setDataElements(x, y, index);
            }
        }

        return indexedImage;
    }

    private void createColorPaletteBox(List<Color> colorPalette) {
        GridPane colorPaletteGrid = new GridPane();
        colorPaletteGrid.setAlignment(Pos.CENTER);
        colorPaletteGrid.setHgap(20);
        colorPaletteGrid.setVgap(10);

        int columnIndex = 0;
        int rowIndex = 0;

        for (Color color : colorPalette) {
            Rectangle colorRect = new Rectangle(30, 30, color);
            DropShadow dropShadow = new DropShadow(10, Color.GRAY);
            colorRect.setEffect(dropShadow);
            colorPaletteGrid.add(colorRect, columnIndex, rowIndex);

            columnIndex++;
            if (columnIndex == 10) {
                columnIndex = 0;
                rowIndex++;
            }
        }

        VBox vbox = new VBox(20, colorPaletteGrid);
        vbox.setAlignment(Pos.CENTER);
        vbox.setPadding(new Insets(10));
        vbox.setStyle("-fx-background-color: #f1f1f1;"); // Set the background color

        ScrollPane scrollPane = new ScrollPane(vbox);
        scrollPane.setFitToWidth(true);
        scrollPane.setFitToHeight(true);

        Scene scene = new Scene(new StackPane(scrollPane), 600, 400);
        Stage stage = new Stage();
        stage.setScene(scene);
        stage.show();
    }

    private void saveImage(javafx.scene.image.Image processedImage) {
        // Check if a processed image is available
        if (processedImage == null) {
            return;
        }

        // Open a file chooser dialog to select the save location and image format
        FileChooser fileChooser = new FileChooser();
        fileChooser.setTitle("Save Image");
        fileChooser.getExtensionFilters().add(new FileChooser.ExtensionFilter("PNG Image", "*.png"));
        File selectedFile = fileChooser.showSaveDialog(new Stage());

        if (selectedFile != null) {
            try {
                int numColors = Integer.parseInt(JOptionPane.showInputDialog("Enter the number of colors"));
                BufferedImage convertToIndexed = convertToIndexed(MedianCut.convertToBufferedImage(processedImage), numColors);
                // Save the processed image in the selected location in PNG format
                ImageIO.write(convertToIndexed, "png", selectedFile);
            } catch (IOException e) {
                System.out.println("Error saving image");
            }
        }
    }
    public void createHistogram(Image image) {
        PixelReader reader = image.getPixelReader();
        final int HISTOGRAM_SIZE = 256;
        int[] redHistogram = new int[HISTOGRAM_SIZE];
        int[] greenHistogram = new int[HISTOGRAM_SIZE];
        int[] blueHistogram = new int[HISTOGRAM_SIZE];

        for (int i = 0; i < image.getWidth() * image.getHeight(); i++) {
            int pixel = reader.getArgb(i % (int) image.getWidth(), i / (int) image.getWidth());
            int alpha = (pixel >> 24) & 0xff;
            int redValue = (pixel >> 16) & 0xff;
            int greenValue = (pixel >> 8) & 0xff;
            int blueValue = pixel & 0xff;
            redHistogram[redValue]++;
            greenHistogram[greenValue]++;
            blueHistogram[blueValue]++;
        }

        CategoryAxis xAxis = new CategoryAxis();
        xAxis.setLabel("Color");

        NumberAxis yAxis = new NumberAxis();
        yAxis.setLabel("Count");

        BarChart<String, Number> chart = new BarChart<>(xAxis, yAxis);
        chart.setTitle("Color Histogram");

        chart.getData().addAll(
                createSeries(redHistogram, "Red"),
                createSeries(greenHistogram, "Green"),
                createSeries(blueHistogram, "Blue")
        );

        HBox vbox = new HBox(20, chart);
        vbox.setAlignment(Pos.BOTTOM_CENTER);
        vbox.setPadding(new Insets(10, 10, 10, 10));
        StackPane root = new StackPane(vbox);
        Scene scene = new Scene(new StackPane(root), 600, 400);

        Stage stage = new Stage();
        stage.setScene(scene);
        stage.show();
    }
    private XYChart.Series<String, Number> createSeries(int[] histogram, String name) {
        XYChart.Series<String, Number> series = new XYChart.Series<>();
        series.setName(name);

        for (int i = 0; i < histogram.length; i++) {
            series.getData().add(new XYChart.Data<>(String.valueOf(i), histogram[i]));
        }

        return series;
    }

}





